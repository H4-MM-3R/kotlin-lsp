import org.gradle.plugins.ide.idea.model.IdeaModel
import org.gradle.plugins.ide.idea.model.IdeaModule

class AndroidPlugin implements Plugin<Project> {

    @Override
    void apply(Project project) {
        if (!project.hasProperty("android")) return

        def variant = System.getProperty("androidVariant")

        project.afterEvaluate {
            def android = project.android

            IdeaModel ideaModel = (IdeaModel)project.extensions.findByName("idea")
            IdeaModule module = ideaModel.module

            // Support both application and library Android modules
            def variants = null
            if (android.hasProperty("applicationVariants")) {
                variants = android.applicationVariants
            } else if (android.hasProperty("libraryVariants")) {
                variants = android.libraryVariants
            } else {
                return
            }

            variants.all { appVariant ->
                if (appVariant.name != variant) return

                // TODO Handle merge conflicts (e.g. debug sourceset overrides main sourceset)
                appVariant.sourceSets.forEach {
                    if(it.name == "test" || it.name == "androidTest") {
                        it.kotlinDirectories.forEach {
                            module.testSourceDirs.add(new File(it.toString()))
                        }
                    } else {
                        it.kotlinDirectories.forEach {
                            module.sourceDirs.add(new File(it.toString()))
                        }
                    }
                }

                // TODO Handle multiple module dependencies
                android.bootClasspath.each {
                    module.sourceDirs.add(new File("jar:${it.path}"))
                }
                def compileClasspathFiles = null
                try {
                    // Prefer the direct variant API when available
                    compileClasspathFiles = appVariant.getCompileClasspath().files
                } catch(Throwable ignored) {
                    // Fallback to configuration-based resolution (e.g. "debugCompileClasspath")
                    def confName = "${appVariant.name}CompileClasspath"
                    def conf = project.configurations.findByName(confName)
                    try {
                        compileClasspathFiles = conf != null ? conf.resolve() : []
                    } catch(Throwable __ignored) {
                        // Do not fail the build if classpath cannot be resolved; proceed without extra deps
                        compileClasspathFiles = []
                    }
                }
                compileClasspathFiles.each {
                    // This is a workaround as we cannot add new dependencies to IdeaModel because of project.afterEvaluate
                    // But we need project.afterEvaluate so compile classpaths can be read
                    module.sourceDirs.add(new File("jar:${it.path}"))
                }
            }
        }
    }
}

allprojects {
    afterEvaluate {
        it.getPlugins().apply("idea")
        it.getPlugins().apply(AndroidPlugin)
    }
}